package Mojolicious::Plugin::Vue3::SFC;
use Mojo::Util qw/dumper trim md5_sum html_unescape/;

use Mojo::Base 'Mojolicious::Plugin', -signatures;
use Mojo::DOM;
use Mojo::Loader qw/data_section/;
use Mojo::File;
use Hash::Merge qw/merge/;

# ------------------------------------------------------------------
# TODO:
# - add functionality to auto-generate a vue 404 and add that to
#   app.js
# - add functionality to cache/save js files
# - add functionality to dump everything to static files
# - add functionality to ensure the index.js page makes sense by adding
#   meta "order" and "description" to the components and links
#   to the components
# ------------------------------------------------------------------

sub dir_to_app {
    # --------------------------------------------------------
    # this generates a viable app.js from components
    # --------------------------------------------------------
    my ($self, $app, $conf) = @_;
    my $base = $conf->{base};
    my $components = Mojo::File->new($base)
	->list_tree
	->grep(qr/\.vue$/)
	->map(sub {
		  return {
			  attr => eval { Mojo::DOM->new($_->slurp)->at("meta")->attr } || "",
			  path => Mojo::File->new("$_" =~ s/\.vue$/.js/r)
			 }
	      })
	->grep(sub { $_->{attr} })
	->map(sub {
		  $_->{attr}->{route} //= "/" . $_->{path}->basename =~ s/\.\w+$//r;
		  sprintf qq[{ path: "%s",  component: () => import("/%s") }], $_->{attr}->{route}, $_->{path};
	      });

    unless (defined $conf->{add_index_component} && !$conf->{add_index_component} ) {
	unshift $components->@*, qq[{ path: "/",  component: () => import("$base/index.js") }];
    }

    my $routes = sprintf "// autogenerated\n\nconst routes = [\n\t%s\n];\n\nexport default { routes };",
	join ",\n\t", $components->@*;

    return $routes
}


sub register ($self, $app, $conf) {
    my $base = $conf->{base} =~ s/^\.//r;
    push @{$app->renderer->classes}, __PACKAGE__;

    if ($conf->{auto_routes}) {
	# --------------------------------------------------------
	# adds app.js to routes
	# --------------------------------------------------------
	$app->routes->get("/app.js" => sub {
			      my $c    = shift;
			      my $routes = $self->dir_to_app($app, $conf);
			      return $c->render(text => $routes, format => 'js');
			  });
    }

    # --------------------------------------------------------
    # adds an automatically generated index.js component
    # --------------------------------------------------------
    unless (defined $conf->{add_index_component} && !$conf->{add_index_component} ) {
	$app->routes->get('/components/index.js' => sub {
			      my $c = shift;
			      my $vue_content = sprintf qq[<template><div><h1>Welcome to %s - a Vue3 + Mojolicious real-time app!</h1></div></template>], $app->moniker;
			      my $output = $c->sfc_to_js($vue_content, $app->moniker);
			      return $c->render(text => $output, format => 'js');
			  });
    }

    # ---------------------------------------------------
    # TODO: check that this can be overridden
    # ---------------------------------------------------
    $app->routes->get('/' => sub { shift()->render(template => 'vue_index', title => $app->moniker) })
	unless (defined $conf->{add_index} && !$conf->{add_index} );

    # ---------------------------------------------------
    # this needs improvement to handle weird paths
    # but I'm not sure what i meant by "weird paths"
    # ---------------------------------------------------

    # --------------------------------------------------------
    # set up up routes to serve compiled components
    # from component base directory
    # --------------------------------------------------------
    $app->routes->get((sprintf '/%s/*name', $base) => [ name => qr/.+\.js$/ ]  => sub { $_[0]->serve_sfc($_[0]->param('name')); })
	unless (defined $conf->{add_component_route} && !$conf->{add_component_route} );


    # --------------------------------------------------------
    # this is the core thing
    # pseudo-compiles a Vue3 SFC to js (hopefully)
    # --------------------------------------------------------
    $app->helper(sfc_to_js => sub {
		     my ($c, $vue_code, $name) = @_;

		     $c->log->info($vue_code);
		     my $dom = Mojo::DOM->new($vue_code);

		     $name //= join "", $app->moniker, "Component";

		     my $vue;
		     $vue->{name}     = $name;

		     # TODO: check that this doesn't match script tag with a single space
		     $vue->{script}   = $dom->at('script') && $dom->at('script')->content =~ /\w/ ? trim($dom->at('script')->content)   : 'export default { template: template }';
		     $vue->{script} =~ s/export default \{/export default \{ template: template, \n/ unless ($vue->{script} =~ /template\s*:/);    # add template if absent

		     $vue->{style}    = $dom->at('style')    ? trim($dom->at('style')->content)    : '';

		     # add an invisible template if there is none
		     $vue->{template} = $dom->at('template') || Mojo::DOM->new('<div style="display:none"></div>');

		     # ----------------------------------------------------------------------
		     # should style be scoped dy default if it isn't: I think it should
		     # ----------------------------------------------------------------------
		     my $is_scoped = $dom->at('style[scoped]') ? 1 : 0;
		     my $id = $name . "-" . substr md5_sum(join "", $name, localtime, rand() * 100 ), 0, 6;

		     # ----------------------------------------------------------------------
		     # this needs fixing for styles where:
		     # - the bracket that is not on the same line as the selector
		     # - there are multiple selector (comma eparated)
		     # ----------------------------------------------------------------------
		     $vue->{style} =~ s/^(.+?\{)/"#" . $id . " " . $1/gsme;

		     $vue->{template}->at("*")->attr("id" => $id);
		     $vue->{template} = html_unescape $vue->{template}->content;
		     $vue->{id} = $id;

		     return $c->render_to_string(inline => data_section(__PACKAGE__, "component.js.ep"), vue => $vue);
		 });
    # --------------------------------------------------------
    # serves the compiled component
    # --------------------------------------------------------
    $app->helper(serve_sfc => sub {
		     my ($c, $name) = @_;
		     my $js_file = Mojo::File->new($conf->{base}, $name);

		     if (-e $js_file) {
			 $c->res->headers->content_type('application/javascript');
			 $c->reply->static($js_file);
		     }

		     my $vue_file = Mojo::File->new($conf->{base}, $name =~ s/\.js/.vue/r);
		     return $c->reply->not_found unless -e $vue_file;

		     my $output = $c->sfc_to_js($vue_file->slurp, $name =~ s/\.\w+//r);
		     return $c->render(text => $output, format => 'js');
    });
}

1
__DATA__
@@ component.js.ep
const template = `<%== $vue->{template} %>`;
<%== $vue->{script} %>

% if ($vue->{style}) {
if (!document.querySelector("#<%== $vue->{id} %>-styles")) {
      const style = document.createElement("style");
      style.id = "<%== $vue->{id} %>-styles";
      style.textContent = `
<%== $vue->{style} %>
`;
      document.head.appendChild(style);
}
% }
@@ vue_index.html.ep
<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <script src="https://unpkg.com/vue@3.2.37"></script>
    <script src="https://unpkg.com/vue-router@4"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>    

    <script type="module">
      import App from "/app.js";
      const app = Vue.createApp(App);
      app.use(VueRouter.createRouter({
        history: VueRouter.createWebHashHistory(),
        routes: App.routes
      }));
      app.mount("#app");
    </script>
  </head>
    <body>
      <div id="app">
	<router-view></router-view>
      </div>
    </body>
</html>
@@ docs.txt

## Config variables

- base: the base dir where the SFC files (i.e.: the components) are stored
- add_index: adds a route "/" that serves vue_index.html with vue pre-configured in
- add_component_route: adds a route that catches all /$base/.+?\.js$ and serves compiled SFCs
- add_index_component: adds an index.vue component that - for now - does nothing useful
- auto_routes: adds a route to an  "/app.js" that's automatically generated from components

## Static components and caching

Static routes have precedence over dynamic ones by default. That means
that a compiled component in a static dir ("public/components" by
default) will be served if it's available. 

On top of that, if a .js file exists, the .vue file will not be compiled, and the .js will be served

## Automatic component routes, app.js and index.js

The auto_routes config variable controls automatic "app.js"
generation; the default is "1". In this case, every component that has
a "meta" tag (including an empty one) in the SFC file will be added to
the routes in "app.js".

The attribute "route" in the meta tag defines the route assigned to it
So a component including:

    <meta route="/nested">

will show up in "app.js" as

    { path: "/nested",  component: () => import("/components/base.js") }

On top of that two attributes in the meta tag control how they will be
shown in the auto-generated index.js file:

- "description" defines the description within the link pointing to the
  component
- "order" defines the order in which it will be shown (by default alphabetically)  
